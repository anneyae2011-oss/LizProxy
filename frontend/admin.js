/**
 * AI Proxy - Admin Dashboard JavaScript
 * Handles admin authentication, configuration, key management, IP banning,
 * request logs, and key analytics
 */

// Constants
const ADMIN_PASSWORD_KEY = 'ai_proxy_admin_password';
const REFRESH_INTERVAL = 3000; // 3 seconds

// State
let adminPassword = null;
let refreshInterval = null;
let consoleMessages = [];
let currentFlags = []; // Store current flags for bulk actions
const MAX_CONSOLE_MESSAGES = 50;

// Render Cache (Prevents jitter/scroll resets on auto-refresh)
let lastFlagsJson = '';
let lastKeysJson = '';
let lastLogsJson = '';
let lastTopJson = '';
let lastBannedJson = '';

// DOM Elements
const passwordModal = document.getElementById('password-modal');
const analyticsModal = document.getElementById('analytics-modal');
const adminContent = document.getElementById('admin-content');
const passwordForm = document.getElementById('password-form');
const passwordError = document.getElementById('password-error');
const adminStatus = document.getElementById('admin-status');
const consoleLog = document.getElementById('console-log');

// Config form elements
const configForm = document.getElementById('config-form');
const targetUrlInput = document.getElementById('target-url');
const targetKeyInput = document.getElementById('target-key');
const maxContextInput = document.getElementById('max-context');
const maxOutputTokensInput = document.getElementById('max-output-tokens');

// Keys table elements
const keysTable = document.getElementById('keys-table');
const keysTbody = document.getElementById('keys-tbody');
const noKeysMessage = document.getElementById('no-keys-message');
const keyCount = document.getElementById('key-count');

// Banned IPs elements
const banIpForm = document.getElementById('ban-ip-form');
const banIpInput = document.getElementById('ban-ip-input');
const banReasonInput = document.getElementById('ban-reason-input');
const bannedTbody = document.getElementById('banned-tbody');
const noBannedMessage = document.getElementById('no-banned-message');

// Request logs elements
const requestLogsEl = document.getElementById('request-logs');
const topRequestsEl = document.getElementById('top-requests');
const analyticsContent = document.getElementById('analytics-content');

/**
 * Initialize the admin dashboard
 */
function init() {
    const storedPassword = sessionStorage.getItem(ADMIN_PASSWORD_KEY);

    if (storedPassword) {
        adminPassword = storedPassword;
        verifyAndLoadDashboard();
    } else {
        showPasswordModal();
    }

    // Start UTC time update
    updateUtcTime();
    setInterval(updateUtcTime, 1000);
}

/**
 * Update UTC time display
 */
function updateUtcTime() {
    const utcTimeEl = document.getElementById('utc-time');
    if (utcTimeEl) {
        const now = new Date();
        utcTimeEl.textContent = now.toUTCString().replace('GMT', 'UTC');
    }
}

/**
 * Add message to console log
 */
function logToConsole(message, type = 'info') {
    const timestamp = new Date().toLocaleTimeString();
    consoleMessages.unshift({ timestamp, message, type });

    // Keep only last N messages
    if (consoleMessages.length > MAX_CONSOLE_MESSAGES) {
        consoleMessages = consoleMessages.slice(0, MAX_CONSOLE_MESSAGES);
    }

    renderConsole();
}

/**
 * Render console log
 */
function renderConsole() {
    if (!consoleLog) return;

    consoleLog.innerHTML = consoleMessages.map(msg => `
        <div class="console-entry ${msg.type}">
            <span class="timestamp">[${msg.timestamp}]</span>
            ${escapeHtml(msg.message)}
        </div>
    `).join('') || '<div class="console-entry info">Waiting for activity...</div>';
}

/**
 * Show the password modal
 */
function showPasswordModal() {
    passwordModal.classList.remove('hidden');
    adminContent.classList.add('hidden');
    document.getElementById('admin-password').focus();
}

/**
 * Hide the password modal and show dashboard
 */
function showDashboard() {
    passwordModal.classList.add('hidden');
    adminContent.classList.remove('hidden');
}

/**
 * Handle password form submission
 */
async function handlePasswordSubmit(event) {
    event.preventDefault();

    const passwordInput = document.getElementById('admin-password');
    const password = passwordInput.value;

    if (!password) {
        showPasswordError('Please enter a password');
        return;
    }

    adminPassword = password;
    const isValid = await verifyPassword();

    if (isValid) {
        sessionStorage.setItem(ADMIN_PASSWORD_KEY, password);
        hidePasswordError();
        showDashboard();
        loadAllData();
        startAutoRefresh();
        logToConsole('Admin authenticated successfully', 'success');
    } else {
        showPasswordError('Invalid password');
        adminPassword = null;
    }
}

/**
 * Verify password by making a test request
 */
async function verifyPassword() {
    try {
        const response = await fetch('/admin/config', {
            headers: { 'X-Admin-Password': adminPassword }
        });
        return response.ok;
    } catch (error) {
        logToConsole(`Auth error: ${error.message}`, 'error');
        return false;
    }
}

/**
 * Verify stored password and load dashboard
 */
async function verifyAndLoadDashboard() {
    const isValid = await verifyPassword();

    if (isValid) {
        showDashboard();
        loadAllData();
        startAutoRefresh();
        logToConsole('Session restored', 'info');
    } else {
        sessionStorage.removeItem(ADMIN_PASSWORD_KEY);
        adminPassword = null;
        showPasswordModal();
    }
}

/**
 * Show password error message
 */
function showPasswordError(message) {
    passwordError.textContent = message;
    passwordError.classList.remove('hidden');
}

/**
 * Hide password error message
 */
function hidePasswordError() {
    passwordError.classList.add('hidden');
}

/**
 * Logout
 */
function logout() {
    sessionStorage.removeItem(ADMIN_PASSWORD_KEY);
    adminPassword = null;
    stopAutoRefresh();
    showPasswordModal();
    document.getElementById('admin-password').value = '';
    logToConsole('Logged out', 'info');
}

/**
 * Start auto-refresh (every 3 seconds)
 */
function startAutoRefresh() {
    stopAutoRefresh();
    refreshInterval = setInterval(() => {
        loadKeys(true);
        loadBannedIps(true);
        loadRequestLogs(true);
        loadTopRequests(true);
        loadFlags(true);
    }, REFRESH_INTERVAL);
}

/**
 * Stop auto-refresh
 */
function stopAutoRefresh() {
    if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
    }
}

/**
 * Load all dashboard data
 */
async function loadAllData() {
    await Promise.all([
        loadConfig(),
        loadKeys(),
        loadBannedIps(),
        loadRequestLogs(),
        loadTopRequests(),
        loadFlags()
    ]);
}

/**
 * Make authenticated admin request
 */
async function adminFetch(url, options = {}) {
    const headers = {
        'X-Admin-Password': adminPassword,
        'Cache-Control': 'no-cache',
        ...options.headers
    };

    try {
        const response = await fetch(url, {
            ...options,
            headers,
            cache: 'no-store'  // Prevent browser caching
        });
        console.log(`[AdminFetch] ${options.method || 'GET'} ${url} -> ${response.status}`);
        return response;
    } catch (error) {
        console.error(`[AdminFetch] ${options.method || 'GET'} ${url} -> Error:`, error);
        throw error;
    }
}


// ===================================
// Configuration Management
// ===================================

async function loadConfig() {
    try {
        const response = await adminFetch('/admin/config');

        if (response.ok) {
            const data = await response.json();
            targetUrlInput.value = data.target_api_url || '';
            targetKeyInput.value = '';
            targetKeyInput.placeholder = data.target_api_key_masked || 'sk-...';
            maxContextInput.value = data.max_context || 128000;
            if (maxOutputTokensInput) maxOutputTokensInput.value = data.max_output_tokens ?? 4096;
            const maxKeysEl = document.getElementById('max-keys-per-ip');
            if (maxKeysEl) maxKeysEl.textContent = data.max_keys_per_ip ?? '‚Äî';
        } else if (response.status === 401) {
            logout();
        } else {
            logToConsole('Failed to load configuration', 'error');
        }
    } catch (error) {
        logToConsole(`Config error: ${error.message}`, 'error');
    }
}

async function saveConfig(event) {
    event.preventDefault();

    const targetUrl = targetUrlInput.value;
    const targetKey = targetKeyInput.value;
    const maxContext = parseInt(maxContextInput.value, 10);
    const maxOutputTokens = maxOutputTokensInput ? parseInt(maxOutputTokensInput.value, 10) : 4096;

    const payload = {
        target_api_url: targetUrl,
        max_context: maxContext,
        max_output_tokens: Math.max(1, Math.min(128000, maxOutputTokens))
    };

    if (targetKey) {
        payload.target_api_key = targetKey;
    }

    try {
        const response = await adminFetch('/admin/config', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (response.ok) {
            logToConsole('Configuration saved', 'success');
            showAdminStatus('Configuration saved successfully', 'success');
            targetKeyInput.value = '';
            await loadConfig();
        } else if (response.status === 401) {
            logout();
        } else {
            const data = await response.json().catch(() => ({}));
            logToConsole(`Config save failed: ${data.error || 'Unknown error'}`, 'error');
            showAdminStatus(data.error || 'Failed to save configuration', 'error');
        }
    } catch (error) {
        logToConsole(`Config save error: ${error.message}`, 'error');
        showAdminStatus('Network error saving configuration', 'error');
    }
}

// ===================================
// Request Logs
// ===================================

async function loadRequestLogs(silent = false) {
    try {
        const response = await adminFetch('/admin/request-logs?limit=40');

        if (response.ok) {
            const logs = await response.json();

            // Optimization: Only update DOM if logs changed
            const logsJson = JSON.stringify(logs);
            if (lastLogsJson === logsJson) return;
            lastLogsJson = logsJson;

            displayRequestLogs(logs);
        } else if (response.status === 401) {
            logout();
        } else if (!silent) {
            logToConsole('Failed to load request logs', 'error');
        }
    } catch (error) {
        if (!silent) {
            logToConsole(`Request logs error: ${error.message}`, 'error');
        }
    }
}

function displayRequestLogs(logs) {
    if (!requestLogsEl) return;

    if (!logs || logs.length === 0) {
        requestLogsEl.innerHTML = '<div class="loading-cell">No requests yet</div>';
        return;
    }

    // Filter out "models" requests (these are just model list fetches, not actual API calls)
    const filteredLogs = logs.filter(log => log.model !== 'models');

    if (filteredLogs.length === 0) {
        requestLogsEl.innerHTML = '<div class="loading-cell">No requests yet</div>';
        return;
    }

    // Update count if element exists
    const countEl = document.getElementById('request-count');
    if (countEl) {
        countEl.textContent = `${filteredLogs.length} recent`;
    }

    requestLogsEl.innerHTML = filteredLogs.map(log => `
        <div class="log-entry ${log.success ? 'success' : 'error'}">
            <div class="log-header">
                <span class="log-model">${escapeHtml(log.model)}</span>
                <span class="log-time">${formatTime(log.request_time)}</span>
            </div>
            <div class="log-details">
                <span class="log-key">${escapeHtml(log.key_prefix)}</span>
                <span class="log-tokens">‚Üì ${formatNumber(log.input_tokens)} ¬∑ ‚Üë ${formatNumber(log.output_tokens)} ¬∑ Œ£ ${formatNumber(log.total_tokens)}</span>
            </div>
            ${log.error_message ? `<div class="log-error">${escapeHtml(log.error_message)}</div>` : ''}
        </div>
    `).join('');
}

async function loadTopRequests(silent = false) {
    try {
        const response = await adminFetch('/admin/top-requests?limit=3');

        if (response.ok) {
            const logs = await response.json();

            // Optimization: Only update DOM if top requests changed
            const topJson = JSON.stringify(logs);
            if (lastTopJson === topJson) return;
            lastTopJson = topJson;

            displayTopRequests(logs);
        } else if (response.status === 401) {
            logout();
        } else if (!silent) {
            logToConsole('Failed to load top requests', 'error');
        }
    } catch (error) {
        if (!silent) {
            logToConsole(`Top requests error: ${error.message}`, 'error');
        }
    }
}

function displayTopRequests(logs) {
    if (!topRequestsEl) return;

    if (!logs || logs.length === 0) {
        topRequestsEl.innerHTML = '<div class="loading-cell">No requests yet</div>';
        return;
    }

    // Filter out "models" requests
    const filteredLogs = logs.filter(log => log.model !== 'models');

    if (filteredLogs.length === 0) {
        topRequestsEl.innerHTML = '<div class="loading-cell">No requests yet</div>';
        return;
    }

    topRequestsEl.innerHTML = filteredLogs.map((log, i) => `
        <div class="log-entry success">
            <div class="log-header">
                <span class="log-model">#${i + 1} ¬∑ ${escapeHtml(log.model)}</span>
                <span class="log-time">${formatTime(log.request_time)}</span>
            </div>
            <div class="log-details">
                <span class="log-key">${escapeHtml(log.key_prefix)}</span>
                <span class="log-tokens">‚úß ${formatNumber(log.total_tokens)} tokens</span>
            </div>
        </div>
    `).join('');
}

// ===================================
// API Keys Management
// ===================================

async function loadKeys(silent = false) {
    if (!silent) {
        keysTbody.innerHTML = '<tr><td colspan="7" class="loading-cell">Loading...</td></tr>';
    }
    noKeysMessage.classList.add('hidden');

    try {
        const response = await adminFetch('/admin/keys');

        if (response.ok) {
            const keys = await response.json();

            // Optimization: Only update DOM if keys changed
            const keysJson = JSON.stringify(keys);
            if (lastKeysJson === keysJson) {
                // Still update counts if they are visible
                if (keyCount) keyCount.textContent = `(${keys.length} keys)`;
                return;
            }
            lastKeysJson = keysJson;

            displayKeys(keys);
            if (keyCount) {
                keyCount.textContent = `(${keys.length} keys)`;
            }
        } else if (response.status === 401) {
            logout();
        } else if (!silent) {
            logToConsole('Failed to load API keys', 'error');
            keysTbody.innerHTML = '<tr><td colspan="7" class="loading-cell">Error loading keys</td></tr>';
        }
    } catch (error) {
        if (!silent) {
            logToConsole(`Keys error: ${error.message}`, 'error');
            keysTbody.innerHTML = '<tr><td colspan="7" class="loading-cell">Error loading keys</td></tr>';
        }
    }
}

function displayKeys(keys) {
    if (!keys || keys.length === 0) {
        keysTbody.innerHTML = '';
        noKeysMessage.classList.remove('hidden');
        displayPendingApplications([]);
        return;
    }

    noKeysMessage.classList.add('hidden');

    // Separate pending applications from active keys
    const pendingKeys = keys.filter(k => !k.enabled && k.rp_application);
    const activeKeys = keys.filter(k => k.enabled || !k.rp_application);

    // Render pending applications in their own section
    displayPendingApplications(pendingKeys);

    // Render active/non-pending keys in the table
    if (activeKeys.length === 0) {
        keysTbody.innerHTML = '';
        noKeysMessage.classList.remove('hidden');
    } else {
        keysTbody.innerHTML = activeKeys.map(key => `
        <tr data-key-id="${key.id}" class="clickable" onclick="showKeyAnalytics(${key.id})">
            <td class="key-prefix">${escapeHtml(key.key_prefix)}</td>
            <td class="discord-email">
                ${escapeHtml(key.discord_email || key.ip_address || 'Unknown')}
                ${key.rp_application ? `<div class="rp-info">RP: ${escapeHtml(key.rp_application.length > 50 ? key.rp_application.substring(0, 50) + '...' : key.rp_application)}</div>` : ''}
            </td>
            <td>
                <span class="status-badge ${key.enabled ? 'enabled' : 'disabled'}">
                    ${key.enabled ? 'Enabled' : 'Disabled'}
                </span>
            </td>
            <td>
                <span class="status-badge ${key.bypass_ip_ban ? 'enabled' : 'disabled'}">
                    ${key.bypass_ip_ban ? 'Bypass' : 'No'}
                </span>
                <div class="action-buttons" onclick="event.stopPropagation()" style="margin-top: 4px;">
                    <button onclick="setBypassIp(${key.id}, ${!key.bypass_ip_ban})"
                            class="btn btn-ghost btn-sm" title="${key.bypass_ip_ban ? 'Disable IP bypass' : 'Allow this key from banned IPs'}">
                        ${key.bypass_ip_ban ? 'Disable bypass' : 'Enable bypass'}
                    </button>
                </div>
            </td>
            <td>${key.current_rpm}/10</td>
            <td title="Tokens today / 150K limit">${key.tokens_used_today != null ? key.tokens_used_today.toLocaleString() : key.current_rpd}/${(150000).toLocaleString()}</td>
            <td>
                <div class="action-buttons" onclick="event.stopPropagation()">
                    <button onclick="toggleKey(${key.id}, ${key.enabled})"
                            class="btn ${key.enabled ? 'btn-warning' : 'btn-ghost'} btn-sm">
                        ${key.enabled ? 'Disable' : 'Enable'}
                    </button>
                    <button onclick="deleteKey(${key.id})" class="btn btn-danger btn-sm">
                        Delete
                    </button>
                </div>
            </td>
        </tr>
    `).join('');
    }
}

/**
 * Display pending applications as prominent cards
 */
function displayPendingApplications(pendingKeys) {
    const section = document.getElementById('pending-section');
    const container = document.getElementById('pending-applications');
    const countEl = document.getElementById('pending-count');

    if (!section || !container) return;

    if (!pendingKeys || pendingKeys.length === 0) {
        section.classList.add('hidden');
        return;
    }

    section.classList.remove('hidden');
    if (countEl) countEl.textContent = `${pendingKeys.length} pending`;

    container.innerHTML = pendingKeys.map(key => `
        <div class="pending-card" data-key-id="${key.id}">
            <div class="pending-card-header">
                <div class="pending-user-info">
                    <span class="pending-icon">‚è≥</span>
                    <div>
                        <div class="pending-user-name">${escapeHtml(key.discord_email || key.ip_address || 'Unknown')}</div>
                        <div class="pending-key-prefix">${escapeHtml(key.key_prefix)}</div>
                    </div>
                </div>
                <span class="status-badge pending">Pending</span>
            </div>
            <div class="pending-card-body">
                <div class="pending-message-label">Their Application:</div>
                <div class="pending-message-text">${escapeHtml(key.rp_application)}</div>
            </div>
            <div class="pending-card-actions">
                <button onclick="approveFromCard(${key.id})" class="btn btn-approve">
                    ‚úì Approve
                </button>
                <button onclick="denyFromCard(${key.id})" class="btn btn-danger">
                    ‚úï Deny
                </button>
            </div>
        </div>
    `).join('');
}

async function setBypassIp(keyId, bypass) {
    try {
        const response = await adminFetch(`/admin/keys/${keyId}/bypass-ip`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bypass })
        });
        if (response.ok) {
            logToConsole(`IP bypass ${bypass ? 'enabled' : 'disabled'} for key`, 'success');
            showAdminStatus(bypass ? 'Key can now be used from banned IPs' : 'IP bypass disabled for this key', 'success');
            await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else if (response.status === 404) {
            logToConsole('Key not found', 'error');
            await loadKeys();
        } else {
            logToConsole('Failed to set IP bypass', 'error');
        }
    } catch (error) {
        logToConsole(`Set bypass error: ${error.message}`, 'error');
    }
}

async function toggleKey(keyId, currentlyEnabled) {
    try {
        const response = await adminFetch(`/admin/keys/${keyId}/toggle`, { method: 'PUT' });

        if (response.ok) {
            logToConsole(`Key ${currentlyEnabled ? 'disabled' : 'enabled'}`, 'success');
            showAdminStatus(`Key ${currentlyEnabled ? 'disabled' : 'enabled'} successfully`, 'success');
            await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else if (response.status === 404) {
            logToConsole('Key not found', 'error');
            await loadKeys();
        } else {
            logToConsole('Failed to toggle key', 'error');
        }
    } catch (error) {
        logToConsole(`Toggle key error: ${error.message}`, 'error');
    }
}

async function deleteKey(keyId) {
    if (!confirm('Are you sure you want to delete this API key?')) return;

    try {
        const response = await adminFetch(`/admin/keys/${keyId}`, { method: 'DELETE' });

        if (response.ok) {
            logToConsole('Key deleted', 'success');
            showAdminStatus('Key deleted successfully', 'success');
            await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else if (response.status === 404) {
            logToConsole('Key not found', 'error');
            await loadKeys();
        } else {
            logToConsole('Failed to delete key', 'error');
        }
    } catch (error) {
        logToConsole(`Delete key error: ${error.message}`, 'error');
    }
}


// ===================================
// Key Analytics Modal
// ===================================

async function showKeyAnalytics(keyId) {
    const modal = document.getElementById('analytics-modal');
    const content = document.getElementById('analytics-content');

    modal.classList.remove('hidden');
    content.innerHTML = '<div class="loading-cell">Loading analytics...</div>';

    try {
        const response = await adminFetch(`/admin/keys/${keyId}/analytics`);

        if (response.ok) {
            const data = await response.json();
            displayKeyAnalytics(data);
            logToConsole(`Loaded analytics for key ${data.key_prefix}`, 'info');
        } else if (response.status === 401) {
            closeAnalyticsModal();
            logout();
        } else if (response.status === 404) {
            content.innerHTML = '<div class="loading-cell">Key not found</div>';
        } else {
            content.innerHTML = '<div class="loading-cell">Failed to load analytics</div>';
        }
    } catch (error) {
        logToConsole(`Analytics error: ${error.message}`, 'error');
        content.innerHTML = '<div class="loading-cell">Error loading analytics</div>';
    }
}

function displayKeyAnalytics(data) {
    const content = document.getElementById('analytics-content');

    const successRate = data.total_requests > 0
        ? Math.round((data.successful_requests / data.total_requests) * 100)
        : 0;

    content.innerHTML = `
        <!-- Key Info Block -->
        <div class="analytics-block key-info-block">
            <div class="block-label">API Key</div>
            <div class="key-info-content">
                <div class="key-mono">${escapeHtml(data.key_prefix)}...</div>
                <div class="key-ip">${escapeHtml(data.ip_address)}</div>
            </div>
        </div>
        
        <!-- Stats Row -->
        <div class="analytics-row">
            <div class="analytics-block stat-block">
                <div class="block-label">Total Tokens</div>
                <div class="stat-big">${formatNumber(data.total_tokens)}</div>
            </div>
            <div class="analytics-block stat-block">
                <div class="block-label">Requests</div>
                <div class="stat-big">${data.total_requests}</div>
            </div>
            <div class="analytics-block stat-block ${successRate >= 80 ? 'stat-success' : successRate >= 50 ? 'stat-warning' : 'stat-danger'}">
                <div class="block-label">Success Rate</div>
                <div class="stat-big">${successRate}%</div>
            </div>
        </div>
        
        <!-- Token Breakdown Row -->
        <div class="analytics-row">
            <div class="analytics-block token-block">
                <div class="block-label">‚Üì Input Tokens</div>
                <div class="stat-medium">${formatNumber(data.total_input_tokens)}</div>
            </div>
            <div class="analytics-block token-block">
                <div class="block-label">‚Üë Output Tokens</div>
                <div class="stat-medium">${formatNumber(data.total_output_tokens)}</div>
            </div>
        </div>
        
        <!-- Model Block -->
        ${data.most_used_model ? `
        <div class="analytics-block model-block">
            <div class="block-label">Most Used Model</div>
            <div class="model-info">
                <span class="model-name">${escapeHtml(data.most_used_model)}</span>
                <span class="model-badge">${data.model_usage_count} requests</span>
            </div>
        </div>
        ` : ''}
        
        <!-- Recent Requests Block -->
        <div class="analytics-block requests-block">
            <div class="block-label">Recent Requests</div>
            <div class="requests-list">
                ${data.recent_requests.length > 0 ? data.recent_requests.map(req => `
                    <div class="request-item ${req.success ? '' : 'request-failed'}">
                        <div class="request-left">
                            <div class="request-model">${escapeHtml(req.model)}</div>
                            <div class="request-time">${formatTime(req.request_time)}</div>
                        </div>
                        <div class="request-right">
                            ${req.total_tokens > 0 ? `<div class="request-tokens">${formatNumber(req.total_tokens)}</div>` : '<div class="request-tokens">-</div>'}
                            <div class="request-status">${req.success ? '‚úì' : '‚úó'}</div>
                        </div>
                    </div>
                `).join('') : '<div class="no-requests">No requests yet</div>'}
            </div>
        </div>
    `;
}

function closeAnalyticsModal() {
    const modal = document.getElementById('analytics-modal');
    modal.classList.add('hidden');
}

// Close modal when clicking outside
document.addEventListener('click', (e) => {
    const modal = document.getElementById('analytics-modal');
    if (e.target === modal) {
        closeAnalyticsModal();
    }
});


// ===================================
// Pending Application Card Actions
// ===================================

async function approveFromCard(keyId) {
    await toggleKey(keyId, false);  // false = currently disabled, so toggle enables it
    logToConsole(`Approved application for key #${keyId}`, 'success');
    showAdminStatus('Application approved ‚Äî key enabled', 'success');
}

async function denyFromCard(keyId) {
    if (!confirm('Deny this application and delete the key?')) return;
    await deleteKey(keyId);
    logToConsole(`Denied application for key #${keyId}`, 'info');
    showAdminStatus('Application denied ‚Äî key deleted', 'info');
}


// ===================================
// Banned IPs Management
// ===================================

async function loadBannedIps(silent = false) {
    if (!silent) {
        bannedTbody.innerHTML = '<tr><td colspan="4" class="loading-cell">Loading...</td></tr>';
    }
    noBannedMessage.classList.add('hidden');

    try {
        const response = await adminFetch('/admin/banned-ips');

        if (response.ok) {
            const ips = await response.json();

            // Optimization: Only update DOM if banned IPs changed
            const bannedJson = JSON.stringify(ips);
            if (lastBannedJson === bannedJson) return;
            lastBannedJson = bannedJson;

            displayBannedIps(ips);
        } else if (response.status === 401) {
            logout();
        } else if (!silent) {
            logToConsole('Failed to load banned IPs', 'error');
            bannedTbody.innerHTML = '<tr><td colspan="4" class="loading-cell">Error loading banned IPs</td></tr>';
        }
    } catch (error) {
        if (!silent) {
            logToConsole(`Banned IPs error: ${error.message}`, 'error');
            bannedTbody.innerHTML = '<tr><td colspan="4" class="loading-cell">Error loading banned IPs</td></tr>';
        }
    }
}

function displayBannedIps(ips) {
    if (!ips || ips.length === 0) {
        bannedTbody.innerHTML = '';
        noBannedMessage.classList.remove('hidden');
        return;
    }

    noBannedMessage.classList.add('hidden');
    bannedTbody.innerHTML = ips.map(ip => `
        <tr>
            <td>${escapeHtml(ip.ip_address)}</td>
            <td>${ip.reason ? escapeHtml(ip.reason) : '<em>No reason</em>'}</td>
            <td>${formatDate(ip.banned_at)}</td>
            <td>
                <button type="button" class="btn btn-ghost btn-sm unban-btn" data-ip="${escapeAttr(ip.ip_address)}">
                    Unban
                </button>
            </td>
        </tr>
    `).join('');
    // Attach unban handlers (avoids putting IP in onclick - XSS safe)
    bannedTbody.querySelectorAll('.unban-btn').forEach(btn => {
        btn.addEventListener('click', () => unbanIp(btn.getAttribute('data-ip')));
    });
}

async function banIp(event) {
    event.preventDefault();

    const ipAddress = banIpInput.value.trim();
    const reason = banReasonInput.value.trim();

    if (!ipAddress) {
        showAdminStatus('Please enter an IP address', 'error');
        return;
    }

    try {
        const response = await adminFetch('/admin/ban-ip', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ip_address: ipAddress, reason: reason || null })
        });

        if (response.ok) {
            logToConsole(`Banned IP: ${ipAddress}`, 'success');
            showAdminStatus(`IP ${ipAddress} has been banned`, 'success');
            banIpInput.value = '';
            banReasonInput.value = '';
            await loadBannedIps();
        } else if (response.status === 401) {
            logout();
        } else {
            const data = await response.json().catch(() => ({}));
            logToConsole(`Ban IP failed: ${data.error || 'Unknown error'}`, 'error');
            showAdminStatus(data.error || 'Failed to ban IP', 'error');
        }
    } catch (error) {
        logToConsole(`Ban IP error: ${error.message}`, 'error');
        showAdminStatus('Network error banning IP', 'error');
    }
}

async function unbanIp(ipAddress) {
    if (!confirm(`Are you sure you want to unban ${ipAddress}?`)) return;

    try {
        const response = await adminFetch(`/admin/ban-ip/${encodeURIComponent(ipAddress)}`, {
            method: 'DELETE'
        });

        if (response.ok) {
            logToConsole(`Unbanned IP: ${ipAddress}`, 'success');
            showAdminStatus(`IP ${ipAddress} has been unbanned`, 'success');
            await loadBannedIps();
        } else if (response.status === 401) {
            logout();
        } else if (response.status === 404) {
            logToConsole('IP not found in ban list', 'error');
            await loadBannedIps();
        } else {
            logToConsole('Failed to unban IP', 'error');
        }
    } catch (error) {
        logToConsole(`Unban IP error: ${error.message}`, 'error');
    }
}


// ===================================
// Rate Limit Reset
// ===================================

async function resetAllRpm() {
    if (!confirm('Are you sure you want to reset RPM counters for all keys?')) return;

    try {
        const response = await adminFetch('/admin/reset-all-rpm', { method: 'POST' });

        if (response.ok) {
            const data = await response.json();
            logToConsole(`Reset RPM for ${data.count} keys`, 'success');
            showAdminStatus(data.message, 'success');
            await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else {
            logToConsole('Failed to reset RPM', 'error');
            showAdminStatus('Failed to reset RPM counters', 'error');
        }
    } catch (error) {
        logToConsole(`Reset RPM error: ${error.message}`, 'error');
        showAdminStatus('Network error resetting RPM', 'error');
    }
}

async function resetAllRpd() {
    if (!confirm('Are you sure you want to reset RPD counters for all keys?')) return;

    try {
        const response = await adminFetch('/admin/reset-all-rpd', { method: 'POST' });

        if (response.ok) {
            const data = await response.json();
            logToConsole(`Reset RPD for ${data.count} keys`, 'success');
            showAdminStatus(data.message, 'success');
            await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else {
            logToConsole('Failed to reset RPD', 'error');
            showAdminStatus('Failed to reset RPD counters', 'error');
        }
    } catch (error) {
        logToConsole(`Reset RPD error: ${error.message}`, 'error');
        showAdminStatus('Network error resetting RPD', 'error');
    }
}


async function purgeAllKeys() {
    if (!confirm('‚ö†Ô∏è WARNING: This will DELETE ALL API keys and usage logs!\n\nEvery user will need to re-register via Discord.\n\nAre you absolutely sure?')) return;
    if (!confirm('FINAL CONFIRMATION: Purge ALL keys? This cannot be undone.')) return;

    try {
        const response = await adminFetch('/admin/purge-all-keys', { method: 'POST' });

        if (response.ok) {
            const data = await response.json();
            logToConsole(`Purged ${data.count} keys and all usage logs`, 'success');
            showAdminStatus(data.message, 'success');
            await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else {
            logToConsole('Failed to purge keys', 'error');
            showAdminStatus('Failed to purge keys', 'error');
        }
    } catch (error) {
        logToConsole(`Purge error: ${error.message}`, 'error');
        showAdminStatus('Network error purging keys', 'error');
    }
}


// ===================================
// Utility Functions
// ===================================

function showAdminStatus(message, type = 'info') {
    if (!adminStatus) return;

    adminStatus.textContent = message;
    adminStatus.className = `status-message ${type}`;
    adminStatus.classList.remove('hidden');

    // Auto-hide after 5 seconds
    setTimeout(() => {
        adminStatus.classList.add('hidden');
    }, 5000);
}

function formatDate(isoString) {
    if (!isoString) return 'N/A';
    const date = new Date(isoString);
    return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
}

function formatTime(isoString) {
    if (!isoString) return 'N/A';
    const date = new Date(isoString);
    return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

function formatNumber(num) {
    if (num === null || num === undefined) return '0';
    if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
    }
    if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
    }
    return num.toLocaleString();
}

function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

/** Escape for HTML attribute value (e.g. data-ip) to prevent break-out and XSS */
function escapeAttr(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML.replace(/"/g, '&quot;');
}


// ===================================
// Theme Management
// ===================================

function toggleTheme() {
    const html = document.documentElement;
    const currentTheme = html.getAttribute('data-theme');
    const newTheme = currentTheme === 'dark' ? 'light' : 'dark';

    html.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
}

function loadTheme() {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
    }
}


// ===================================
// Content Moderation Flags
// ===================================

async function loadFlags(silent = false) {
    const container = document.getElementById('flags-container');
    const section = document.getElementById('flags-section');
    const noFlagsMessage = document.getElementById('no-flags-message');
    const countEl = document.getElementById('flags-count');
    const showReviewed = document.getElementById('show-reviewed-flags')?.checked || false;

    if (!container || !section) return;

    // Always show the flags section so admin can see it
    section.classList.remove('hidden');

    if (!silent) {
        container.innerHTML = '<div class="loading-cell">Loading...</div>';
    }

    try {
        const response = await adminFetch(`/admin/flags?include_reviewed=${showReviewed}`);

        if (response.ok) {
            const flags = await response.json();

            // Optimization: Only update DOM if flags have actually changed
            // This prevents "jumping" and scroll reset every 3 seconds
            const flagsJson = JSON.stringify(flags);
            if (lastFlagsJson === flagsJson) {
                return;
            }
            lastFlagsJson = flagsJson;

            currentFlags = flags; // Save for bulk actions
            displayFlags(flags);

            if (countEl) {
                const unreviewedCount = flags.filter(f => !f.reviewed).length;
                countEl.textContent = unreviewedCount > 0 ? `${unreviewedCount} unreviewed` : 'None';
            }
        } else if (response.status === 401) {
            logout();
        } else if (!silent) {
            logToConsole('Failed to load content flags', 'error');
        }
    } catch (error) {
        if (!silent) {
            logToConsole(`Flags error: ${error.message}`, 'error');
        }
    }
}

function displayFlags(flags) {
    const container = document.getElementById('flags-container');
    const noFlagsMessage = document.getElementById('no-flags-message');

    if (!container) return;

    if (!flags || flags.length === 0) {
        container.innerHTML = '';
        if (noFlagsMessage) noFlagsMessage.classList.remove('hidden');
        return;
    }

    if (noFlagsMessage) noFlagsMessage.classList.add('hidden');

    container.innerHTML = flags.map(flag => `
        <div class="flag-card ${flag.reviewed ? 'reviewed' : ''} severity-${flag.severity}" data-flag-id="${flag.id}">
            <div class="flag-card-header">
                <div class="flag-info">
                    <span class="flag-type-badge ${flag.flag_type}">${escapeHtml(flag.flag_type.toUpperCase())}</span>
                    <span class="flag-severity-badge ${flag.severity}">${escapeHtml(flag.severity)}</span>
                </div>
                <span class="flag-time">${formatTime(flag.flagged_at)}</span>
            </div>
            <div class="flag-card-body">
                <div class="flag-user-info">
                    <strong>User:</strong> ${escapeHtml(flag.discord_email || flag.discord_id || 'Unknown')}
                </div>
                <div class="flag-key-info">
                    <strong>Key:</strong> ${escapeHtml(flag.key_prefix)} | <strong>IP:</strong> ${escapeHtml(flag.ip_address)}
                </div>
                <div class="flag-model-info">
                    <strong>Model:</strong> ${escapeHtml(flag.model)}
                </div>
                <div class="flag-preview">
                    <strong>Flagged Content:</strong>
                    <pre class="flag-content-preview">${escapeHtml(flag.message_preview) || '<span class="empty-preview">(No flagged text content)</span>'}</pre>
                </div>
            </div>
            ${flag.reviewed ? `
                <div class="flag-reviewed-info">
                    <span class="reviewed-badge">‚úì Reviewed</span>
                    <span class="action-taken">${escapeHtml(flag.action_taken || 'No action')}</span>
                </div>
            ` : `
                <div class="flag-card-actions">
                    <button onclick="flagAction(${flag.id}, 'ban_and_disable')" class="btn btn-ban-user" title="Ban this user's IP and disable their key">
                        üö´ Ban User
                    </button>
                    <button onclick="flagAction(${flag.id}, 'ban_ip')" class="btn btn-warning btn-sm" title="Ban IP only">
                        Ban IP
                    </button>
                    <button onclick="flagAction(${flag.id}, 'disable_key')" class="btn btn-warning btn-sm" title="Disable key only">
                        Disable Key
                    </button>
                    <button onclick="flagAction(${flag.id}, 'dismiss')" class="btn btn-ghost btn-sm" title="Dismiss without action">
                        Dismiss
                    </button>
                </div>
            `}
        </div>
    `).join('');
}

async function flagAction(flagId, action) {
    const actionLabels = {
        'ban_ip': 'ban this IP',
        'disable_key': 'disable this API key',
        'ban_and_disable': 'ban the IP AND disable the key',
        'dismiss': 'dismiss this flag without action',
        'warn': 'mark as warned'
    };

    if (!confirm(`Are you sure you want to ${actionLabels[action] || action}?`)) return;

    try {
        const response = await adminFetch(`/admin/flags/${flagId}/action`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action })
        });

        if (response.ok) {
            const data = await response.json();
            logToConsole(`Flag action: ${data.message}`, 'success');
            showAdminStatus(data.message, 'success');
            await loadFlags();
            // Also refresh banned IPs if we banned someone
            if (action === 'ban_ip' || action === 'ban_and_disable') {
                await loadBannedIps();
            }
            // Refresh keys if we disabled one
            if (action === 'disable_key' || action === 'ban_and_disable') {
                await loadKeys();
            }
        } else if (response.status === 401) {
            logout();
        } else if (response.status === 404) {
            logToConsole('Flag not found', 'error');
            await loadFlags();
        } else {
            const data = await response.json().catch(() => ({}));
            logToConsole(`Flag action failed: ${data.detail || 'Unknown error'}`, 'error');
            showAdminStatus(data.detail || 'Failed to process flag action', 'error');
        }
    } catch (error) {
        logToConsole(`Flag action error: ${error.message}`, 'error');
        showAdminStatus('Network error processing flag action', 'error');
    }
}

async function bulkFlagAction(action) {
    const unreviewed = currentFlags.filter(f => !f.reviewed);
    if (unreviewed.length === 0) {
        showAdminStatus('No unreviewed flags to act on', 'info');
        return;
    }

    const actionLabels = {
        'ban_ip': 'ban ALL unreviewed IPs',
        'disable_key': 'disable ALL unreviewed API keys',
        'ban_and_disable': 'ban and disable ALL unreviewed users',
        'dismiss': 'dismiss ALL unreviewed flags'
    };

    if (!confirm(`Are you sure you want to ${actionLabels[action] || action} (${unreviewed.length} total)?`)) return;

    const flagIds = unreviewed.map(f => f.id);

    try {
        logToConsole(`Bulk action '${action}' started for ${flagIds.length} flags...`, 'info');

        const response = await adminFetch('/admin/flags/bulk-action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                flag_ids: flagIds,
                action: action,
                reason: `Bulk ${action} from Admin Dashboard`
            })
        });

        if (response.ok) {
            const data = await response.json();
            logToConsole(data.message, 'success');
            showAdminStatus(data.message, 'success');
            await loadFlags();
            // Refresh other lists if needed
            if (action.includes('ban')) await loadBannedIps();
            if (action.includes('disable') || action.includes('ban')) await loadKeys();
        } else if (response.status === 401) {
            logout();
        } else {
            const data = await response.json().catch(() => ({}));
            logToConsole(`Bulk action failed: ${data.message || 'Unknown error'}`, 'error');
            showAdminStatus(data.message || 'Failed to process bulk action', 'error');
        }
    } catch (error) {
        logToConsole(`Bulk action error: ${error.message}`, 'error');
        showAdminStatus('Network error processing bulk action', 'error');
    }
}


// ===================================
// Initialization
// ===================================

document.addEventListener('DOMContentLoaded', () => {
    loadTheme();
    init();
});
